# 🔍 问题分析与解决方案

## 核心问题

### 问题1: Frontend SSR时API URL配置错误 ❌

**现象**：
```
getBaseUrl http://localhost:3000/v1
```

**原因**：
Next.js使用了**服务端渲染（SSR）**，在服务端无法访问浏览器的 `window.APP_CONFIG`。代码中有两套配置：

```typescript
// client/src/utils/axiosUtils.tsx
const getBaseUrl = () => {
    if (typeof window !== 'undefined' && window.APP_CONFIG) {
        return window.APP_CONFIG.API_URL;  // 浏览器端 ✅
    }
    return process.env.NEXT_PUBLIC_API_URL;  // 服务端 ❌ (未设置)
};
```

**问题链**：
1. Docker构建时没有传递 `NEXT_PUBLIC_API_URL` 环境变量
2. Next.js在构建时将 `undefined` 硬编码到代码中
3. 服务端渲染时回退到默认值 `http://localhost:3000/v1`
4. 浏览器中API请求发送到 `localhost`，导致 `ERR_CONNECTION_REFUSED`

---

## ✅ 解决方案

### 修改1: `client/Dockerfile.prod`
添加构建时环境变量：

```dockerfile
# 设置构建时的环境变量
ARG NEXT_PUBLIC_API_URL
ENV NEXT_PUBLIC_API_URL=${NEXT_PUBLIC_API_URL}

# 构建应用
RUN npm run build
```

### 修改2: `docker-compose.prod.yml`
传递构建参数：

```yaml
frontend:
  build:
    context: ./client
    dockerfile: Dockerfile.prod
    args:
      NEXT_PUBLIC_API_URL: ${BASE_URL}/v1  # 从 .env.prod 读取
```

### 修改3: `client/public/config.js`
使用动态URL（支持不同域名）：

```javascript
window.APP_CONFIG = {
    API_URL: window.location.origin + '/v1',  // 自动适配当前域名
    ASSET_PREFIX: window.location.origin,
    WECHAT_APP_ID: 'wx24cf9fafe860e29d'
};
```

### 修改4: `client/src/utils/axiosUtils.tsx`
添加安全默认值：

```typescript
const getBaseUrl = () => {
    if (typeof window !== 'undefined' && window.APP_CONFIG) {
        return window.APP_CONFIG.API_URL;
    }
    // 使用环境变量，如果没有则使用相对路径
    return process.env.NEXT_PUBLIC_API_URL || '/v1';
};
```

---

## 🚀 部署步骤

### 在服务器上执行：

```bash
# 1. 进入项目目录
cd /opt/mini-shop

# 2. 拉取最新代码
git pull

# 3. 执行快速修复脚本
chmod +x quick-fix.sh
./quick-fix.sh
```

### 或者手动执行：

```bash
cd /opt/mini-shop
git pull

# 停止服务
docker-compose -f docker-compose.prod.yml --env-file .env.prod down

# 删除旧镜像
docker rmi mini-shop-frontend

# 重新构建（关键：使用 --no-cache 和 --env-file）
docker-compose -f docker-compose.prod.yml --env-file .env.prod build --no-cache frontend

# 启动服务
docker-compose -f docker-compose.prod.yml --env-file .env.prod up -d

# 等待30秒
sleep 30

# 检查日志（应该看到正确的URL）
docker logs shop-frontend-prod | grep "getBaseUrl"
```

---

## 🧪 验证修复

### 1. 检查Frontend日志
应该看到：
```
getBaseUrl https://waimaimeituan.dpdns.org/v1  ✅
```

而不是：
```
getBaseUrl http://localhost:3000/v1  ❌
```

### 2. 浏览器测试
打开 https://waimaimeituan.dpdns.org，按 F12 查看：
- **Console**: 应该看到 `APP_CONFIG` 显示正确的URL
- **Network**: API请求应该发送到 `https://waimaimeituan.dpdns.org/v1/...`

### 3. 后台管理
访问 https://waimaimeituan.dpdns.org/admin
- 应该正常显示界面（不再404）
- 可以正常登录（用户名：admin，密码：123456）

---

## 📚 技术原理

### Next.js环境变量的两个阶段：

1. **构建时（Build Time）**
   - Next.js在 `npm run build` 时将环境变量硬编码到代码中
   - **必须**在构建时设置 `NEXT_PUBLIC_*` 变量
   - 这就是为什么修改 `.env.prod` 后需要重新构建

2. **运行时（Runtime）**
   - 浏览器中可以访问 `window.APP_CONFIG`
   - 服务端无法访问浏览器变量，只能使用构建时设置的值

### Docker构建参数（ARG）vs 环境变量（ENV）：

```dockerfile
ARG NEXT_PUBLIC_API_URL        # 构建时参数（从docker-compose传入）
ENV NEXT_PUBLIC_API_URL=${...} # 转换为环境变量（供npm build使用）
```

---

## 🎯 为什么之前修改 `config.js` 没用？

你的修改是正确的，但只解决了**浏览器端**的问题。

Next.js的SSR流程：
1. **服务端渲染**首屏HTML（此时无法访问 `window.APP_CONFIG`） ❌
2. 发送HTML到浏览器
3. **浏览器端水合**（Hydration），加载 `config.js` ✅

问题在第1步：首屏渲染时已经使用错误的 `localhost` URL加载数据，导致失败。

---

## ✅ 现在的完整流程

1. ✅ `.env.prod` 定义 `BASE_URL=https://waimaimeituan.dpdns.org`
2. ✅ `docker-compose.prod.yml` 传递构建参数 `NEXT_PUBLIC_API_URL=${BASE_URL}/v1`
3. ✅ `Dockerfile.prod` 接收ARG并转换为ENV
4. ✅ `npm run build` 使用环境变量构建
5. ✅ 服务端渲染使用正确的 `https://waimaimeituan.dpdns.org/v1`
6. ✅ 浏览器端使用 `window.APP_CONFIG`（兼容本地开发）

完美！🎉

